<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>K-Means Clustering - Machine Learning Cookbook(V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/v4-shims.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#8B5CF6',
                        accent: '#10B981',
                        neutral: '#6B7280',
                        dark: '#1F2937',
                        light: '#F9FAFB'
                    },
                    fontFamily: {
                        code: ['Consolas', 'Monaco', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .math-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            .code-card {
                background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            }
            .interactive-card {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            }
            .formula-highlight {
                background: linear-gradient(45deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
                border-left: 4px solid #8B5CF6;
            }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="bg-white rounded-xl shadow-lg p-6">
        <!-- Algorithm Header -->
        <div class="mb-8">
            <div class="flex items-center mb-4">
                <i class="fa fa-clone text-3xl text-accent mr-4"></i>
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">K-Means Clustering</h1>
                    <p class="text-gray-600">Unsupervised Learning - Clustering Algorithm</p>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 mb-4">
                <span class="bg-accent/10 text-accent px-3 py-1 rounded-full text-sm">Clustering</span>
                <span class="bg-primary/10 text-primary px-3 py-1 rounded-full text-sm">Unsupervised</span>
                <span class="bg-secondary/10 text-secondary px-3 py-1 rounded-full text-sm">Centroid-based</span>
                <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm">Iterative</span>
            </div>
        </div>

        <!-- Algorithm Overview -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Algorithm Overview</h2>
            <div class="bg-gray-50 p-6 rounded-lg">
                <p class="text-gray-700 mb-4">
                    K-Means is a partitioning clustering algorithm that divides n observations into k clusters 
                    where each observation belongs to the cluster with the nearest mean (centroid).
                </p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-bold text-gray-800 mb-2">Key Characteristics</h3>
                        <ul class="list-disc list-inside text-gray-700 space-y-1">
                            <li>Partitions data into k distinct clusters</li>
                            <li>Each cluster has a centroid (mean of points)</li>
                            <li>Minimizes within-cluster variance</li>
                            <li>Requires specifying k in advance</li>
                            <li>Simple and efficient for large datasets</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="font-bold text-gray-800 mb-2">Applications</h3>
                        <ul class="list-disc list-inside text-gray-700 space-y-1">
                            <li>Customer segmentation</li>
                            <li>Image compression</li>
                            <li>Document clustering</li>
                            <li>Anomaly detection</li>
                            <li>Market basket analysis</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mathematical Foundations -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Mathematical Foundations</h2>
            
            <!-- Objective Function -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">1. Objective Function</h3>
                <div class="formula-highlight p-4 rounded-lg mb-4">
                    <p class="text-lg font-mono">\[ J = \sum_{i=1}^{k} \sum_{x \in C_i} \| x - \mu_i \|^2 \]</p>
                    <p class="text-gray-600 text-sm mt-2">Where \( C_i \) is the i-th cluster and \( \mu_i \) is its centroid</p>
                </div>
            </div>

            <!-- Algorithm Steps -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">2. Algorithm Steps</h3>
                <div class="bg-white p-4 rounded-lg shadow-md mb-4">
                    <ol class="list-decimal list-inside text-gray-700 space-y-2">
                        <li><span class="font-bold">Initialization:</span> Randomly select k centroids</li>
                        <li><span class="font-bold">Assignment:</span> Assign each point to the nearest centroid</li>
                        <li><span class="font-bold">Update:</span> Recalculate centroids as mean of assigned points</li>
                        <li><span class="font-bold">Convergence:</span> Repeat until centroids stabilize</li>
                    </ol>
                </div>
            </div>

            <!-- Distance Metrics -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">3. Distance Metrics</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="formula-highlight p-4 rounded-lg">
                        <h4 class="font-bold text-gray-800 mb-2">Euclidean Distance</h4>
                        <p class="text-lg font-mono">\[ d(x, y) = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2} \]</p>
                        <p class="text-sm text-gray-600 mt-2">Most commonly used</p>
                    </div>
                    <div class="formula-highlight p-4 rounded-lg">
                        <h4 class="font-bold text-gray-800 mb-2">Manhattan Distance</h4>
                        <p class="text-lg font-mono">\[ d(x, y) = \sum_{i=1}^{n} |x_i - y_i| \]</p>
                        <p class="text-sm text-gray-600 mt-2">L1 distance, less sensitive to outliers</p>
                    </div>
                </div>
            </div>

            <!-- Choosing K -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">4. Choosing Optimal K</h3>
                <div class="formula-highlight p-4 rounded-lg mb-4">
                    <h4 class="font-bold text-gray-800 mb-2">Elbow Method</h4>
                    <p class="text-gray-700 mb-2">Plot the within-cluster sum of squares (WCSS) against k and look for the "elbow" point</p>
                    <canvas id="elbowChart" width="400" height="200"></canvas>
                </div>
            </div>
        </div>

        <!-- Implementation -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Implementation</h2>
            
            <!-- Python Code -->
            <div class="code-card text-white p-6 rounded-lg mb-6">
                <pre class="font-code text-sm overflow-x-auto"><code>import numpy as np
from sklearn.cluster import KMeans
from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt

# Generate sample data
X, y_true = make_blobs(n_samples=300, centers=4, cluster_std=0.60, random_state=0)

# Create and train K-Means model
kmeans = KMeans(n_clusters=4, random_state=0)
kmeans.fit(X)
y_kmeans = kmeans.predict(X)

# Get cluster centers
centers = kmeans.cluster_centers_

# Evaluate using inertia (WCSS)
print(f"Inertia (WCSS): {kmeans.inertia_:.2f}")

# Plot results
plt.scatter(X[:, 0], X[:, 1], c=y_kmeans, s=50, cmap='viridis')
plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.75, marker='X')
plt.title('K-Means Clustering Results')
plt.show()

# Elbow method to find optimal k
inertias = []
k_values = range(1, 11)
for k in k_values:
    kmeans = KMeans(n_clusters=k, random_state=0)
    kmeans.fit(X)
    inertias.append(kmeans.inertia_)

plt.plot(k_values, inertias, 'bx-')
plt.xlabel('Number of clusters (k)')
plt.ylabel('Inertia (WCSS)')
plt.title('Elbow Method for Optimal k')
plt.show()</code></pre>
            </div>

            <!-- Interactive Demo -->
            <div class="interactive-card text-white p-6 rounded-lg">
                <h3 class="text-xl font-bold mb-4">Interactive K-Means Demo</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label class="block mb-2 font-bold">Number of Clusters (k):</label>
                        <input type="number" id="numClusters" value="3" min="2" max="10" class="w-full p-2 rounded-lg mb-4 text-gray-800">
                        
                        <label class="block mb-2 font-bold">Number of Points:</label>
                        <input type="number" id="numPoints" value="100" min="50" max="500" class="w-full p-2 rounded-lg mb-4 text-gray-800">
                        
                        <button onclick="runKMeans()" class="bg-white text-green-600 px-4 py-2 rounded-lg hover:bg-gray-100 transition-colors duration-200 font-bold">
                            Run K-Means
                        </button>
                    </div>
                    <div>
                        <canvas id="kmeansChart" width="400" height="300" style="background-color: white;"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mathematical Theory Card -->
        <div class="math-card text-white p-6 rounded-lg mb-8">
            <h3 class="text-xl font-bold mb-4">Mathematical Theory</h3>
            <div class="space-y-4">
                <div>
                    <h4 class="font-bold mb-2">Convergence Properties</h4>
                    <p class="text-sm">K-Means is guaranteed to converge because the objective function is non-increasing and bounded below. However, it may converge to a local minimum rather than the global minimum.</p>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Theoretical Guarantees</h4>
                    <p class="text-sm">Under certain conditions, K-Means can find a solution that is within a constant factor of the optimal solution. The approximation ratio depends on the initialization method.</p>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Computational Complexity</h4>
                    <p class="text-sm">The time complexity is \( O(n k d i) \) where:
                    <ul class="list-disc list-inside text-xs mt-1">
                        <li>n = number of points</li>
                        <li>k = number of clusters</li>
                        <li>d = dimensionality</li>
                        <li>i = number of iterations</li>
                    </ul>
                    </p>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Variants</h4>
                    <p class="text-sm">
                        <span class="font-bold">K-Means++:</span> Improved initialization that selects initial centroids to be far apart<br>
                        <span class="font-bold">Mini-Batch K-Means:</span> Uses mini-batches for faster convergence on large datasets<br>
                        <span class="font-bold">Fuzzy K-Means:</span> Allows points to belong to multiple clusters with membership probabilities
                    </p>
                </div>
            </div>
        </div>

        <!-- Evaluation Metrics -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Evaluation Metrics</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-calculator text-2xl text-red-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">WCSS</h3>
                    <p class="text-sm text-gray-600">Within-Cluster Sum of Squares</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-check-circle text-2xl text-blue-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Silhouette</h3>
                    <p class="text-sm text-gray-600">Silhouette Coefficient</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-star text-2xl text-green-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Calinski-Harabasz</h3>
                    <p class="text-sm text-gray-600">Variance Ratio Criterion</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-thumbs-up text-2xl text-purple-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Davies-Bouldin</h3>
                    <p class="text-sm text-gray-600">Cluster Separation Metric</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Elbow method visualization
        function plotElbowMethod() {
            const ctx = document.getElementById('elbowChart').getContext('2d');
            
            // Sample elbow data
            const kValues = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            const inertias = [2500, 1200, 600, 300, 250, 220, 200, 180, 170, 160];
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: kValues,
                    datasets: [{
                        label: 'WCSS (Inertia)',
                        data: inertias,
                        borderColor: '#10B981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        borderWidth: 3,
                        pointBackgroundColor: '#10B981',
                        pointRadius: 5,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Number of Clusters (k)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'WCSS (Inertia)'
                            },
                            min: 0
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Elbow Method for Optimal k Selection'
                        }
                    }
                }
            });
        }

        // Interactive K-Means demo
        function runKMeans() {
            const k = parseInt(document.getElementById('numClusters').value);
            const n = parseInt(document.getElementById('numPoints').value);
            
            // Generate random data
            const data = generateRandomData(n, k);
            
            // Simple K-Means implementation
            const { clusters, centroids } = kmeansAlgorithm(data, k);
            
            // Plot results
            plotKMeansResults(clusters, centroids);
        }

        function generateRandomData(n, k) {
            const data = [];
            const centers = [];
            
            // Create random centers
            for (let i = 0; i < k; i++) {
                centers.push([
                    Math.random() * 100,
                    Math.random() * 100
                ]);
            }
            
            // Generate points around centers
            for (let i = 0; i < n; i++) {
                const centerIdx = Math.floor(Math.random() * k);
                const center = centers[centerIdx];
                data.push([
                    center[0] + (Math.random() - 0.5) * 20,
                    center[1] + (Math.random() - 0.5) * 20
                ]);
            }
            
            return data;
        }

        function kmeansAlgorithm(data, k) {
            // Initialize centroids randomly from data points
            let centroids = [];
            const dataCopy = [...data];
            for (let i = 0; i < k; i++) {
                const randomIndex = Math.floor(Math.random() * dataCopy.length);
                centroids.push(dataCopy.splice(randomIndex, 1)[0]);
            }
            let clusters;
            
            // Iterate until convergence
            for (let iter = 0; iter < 100; iter++) {
                // Assign points to clusters
                clusters = Array(k).fill().map(() => []);
                data.forEach(point => {
                    const distances = centroids.map(c => euclideanDistance(point, c));
                    const clusterIdx = distances.indexOf(Math.min(...distances));
                    clusters[clusterIdx].push(point);
                });
                
                // Update centroids
                const newCentroids = clusters.map(cluster => {
                    if (cluster.length === 0) return centroids[clusters.indexOf(cluster)];
                    return cluster.reduce((sum, point) => [
                        sum[0] + point[0],
                        sum[1] + point[1]
                    ], [0, 0]).map(s => s / cluster.length);
                });
                
                // Check for convergence
                if (centroids.every((c, i) => 
                    euclideanDistance(c, newCentroids[i]) < 0.001)) {
                    break;
                }
                
                centroids = newCentroids;
            }
            
            return { clusters, centroids };
        }

        function euclideanDistance(a, b) {
            return Math.sqrt(
                Math.pow(a[0] - b[0], 2) + 
                Math.pow(a[1] - b[1], 2)
            );
        }

        // Global chart variable to manage instances
        let kmeansChartInstance = null;

        function plotKMeansResults(clusters, centroids) {
            const ctx = document.getElementById('kmeansChart').getContext('2d');
            
            // Destroy previous chart instance if it exists
            if (kmeansChartInstance) {
                kmeansChartInstance.destroy();
            }
            
            // Prepare data for Chart.js
            const datasets = clusters.map((cluster, i) => {
                const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
                return {
                    label: `Cluster ${i + 1}`,
                    data: cluster.map(point => ({ x: point[0], y: point[1] })),
                    backgroundColor: colors[i % colors.length] + '80',
                    borderColor: colors[i % colors.length],
                    borderWidth: 2,
                    pointRadius: 5,
                    showLine: false
                };
            });
            
            // Add centroids dataset
            datasets.push({
                label: 'Centroids',
                data: centroids.map(centroid => ({ x: centroid[0], y: centroid[1] })),
                backgroundColor: '#FF0000',
                borderColor: '#FF0000',
                borderWidth: 3,
                pointRadius: 8,
                pointStyle: 'crossRot',
                showLine: false
            });
            
            // Create new chart instance
            kmeansChartInstance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    backgroundColor: '#FFFFFF',
                    scales: {
                        x: { title: { display: true, text: 'Feature 1' }, min: 0, max: 100 },
                        y: { title: { display: true, text: 'Feature 2' }, min: 0, max: 100 }
                    },
                    plugins: {
                        title: { display: true, text: 'K-Means Clustering Results' }
                    }
                }
            });
        }

        // Initialize charts when page loads
        document.addEventListener('DOMContentLoaded', function() {
            plotElbowMethod();
            runKMeans(); // Run initial demo
        });
    </script>
</body>
</html>