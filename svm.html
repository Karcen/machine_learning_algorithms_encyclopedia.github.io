<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support Vector Machine - Machine Learning Cookbook(V2)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/v4-shims.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#8B5CF6',
                        accent: '#10B981',
                        neutral: '#6B7280',
                        dark: '#1F2937',
                        light: '#F9FAFB'
                    },
                    fontFamily: {
                        code: ['Consolas', 'Monaco', 'monospace'],
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
    
    <style type="text/tailwindcss">
        @layer utilities {
            .content-auto {
                content-visibility: auto;
            }
            .math-card {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            .code-card {
                background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            }
            .interactive-card {
                background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            }
            .formula-highlight {
                background: linear-gradient(45deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
                border-left: 4px solid #8B5CF6;
            }
        }
    </style>
</head>
<body class="bg-gray-50">
    <div class="bg-white rounded-xl shadow-lg p-6">
        <!-- Algorithm Header -->
        <div class="mb-8">
            <div class="flex items-center mb-4">
                <i class="fa fa-area-chart text-3xl text-yellow-500 mr-4"></i>
                <div>
                    <h1 class="text-3xl font-bold text-gray-800">Support Vector Machine</h1>
                    <p class="text-gray-600">Supervised Learning - Classification Algorithm</p>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 mb-4">
                <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm">Classification</span>
                <span class="bg-primary/10 text-primary px-3 py-1 rounded-full text-sm">Margin Maximization</span>
                <span class="bg-secondary/10 text-secondary px-3 py-1 rounded-full text-sm">Kernel Trick</span>
                <span class="bg-accent/10 text-accent px-3 py-1 rounded-full text-sm">Non-linear</span>
            </div>
        </div>

        <!-- Algorithm Overview -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Algorithm Overview</h2>
            <div class="bg-gray-50 p-6 rounded-lg">
                <p class="text-gray-700 mb-4">
                    Support Vector Machine (SVM) is a powerful classification algorithm that finds the optimal hyperplane 
                    which maximizes the margin between different classes in the feature space.
                </p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-bold text-gray-800 mb-2">Key Characteristics</h3>
                        <ul class="list-disc list-inside text-gray-700 space-y-1">
                            <li>Finds optimal separating hyperplane</li>
                            <li>Maximizes margin between classes</li>
                            <li>Uses support vectors (critical points)</li>
                            <li>Handles non-linear problems with kernels</li>
                            <li>Effective in high-dimensional spaces</li>
                        </ul>
                    </div>
                    <div>
                        <h3 class="font-bold text-gray-800 mb-2">Applications</h3>
                        <ul class="list-disc list-inside text-gray-700 space-y-1">
                            <li>Image classification</li>
                            <li>Text categorization</li>
                            <li>Bioinformatics</li>
                            <li>Handwriting recognition</li>
                            <li>Face detection</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mathematical Foundations -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Mathematical Foundations</h2>
            
            <!-- Linear SVM -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">1. Linear SVM</h3>
                <div class="formula-highlight p-4 rounded-lg mb-4">
                    <p class="text-lg font-mono">\[ \text{Maximize: } \frac{2}{\|\mathbf{w}\|} \]</p>
                    <p class="text-lg font-mono mt-2">\[ \text{Subject to: } y_i(\mathbf{w}^T \mathbf{x}_i + b) \geq 1 \quad \forall i \]</p>
                    <p class="text-gray-600 text-sm mt-2">Where \( \mathbf{w} \) is the weight vector and \( b \) is the bias term</p>
                </div>
                
                <!-- SVM Margin Visualization -->
                <div class="bg-white p-4 rounded-lg shadow-md mb-4">
                    <canvas id="svmMarginChart" width="400" height="300"></canvas>
                </div>
            </div>

            <!-- Soft Margin SVM -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">2. Soft Margin SVM</h3>
                <div class="formula-highlight p-4 rounded-lg mb-4">
                    <p class="text-lg font-mono">\[ \text{Minimize: } \frac{1}{2}\|\mathbf{w}\|^2 + C \sum_{i=1}^{n} \xi_i \]</p>
                    <p class="text-lg font-mono mt-2">\[ \text{Subject to: } y_i(\mathbf{w}^T \mathbf{x}_i + b) \geq 1 - \xi_i, \quad \xi_i \geq 0 \]</p>
                    <p class="text-gray-600 text-sm mt-2">\( C \) controls the trade-off between margin size and classification error</p>
                </div>
            </div>

            <!-- Kernel Trick -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">3. Kernel Trick</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="formula-highlight p-4 rounded-lg">
                        <h4 class="font-bold text-gray-800 mb-2">Kernel Function</h4>
                        <p class="text-lg font-mono">\[ K(\mathbf{x}_i, \mathbf{x}_j) = \phi(\mathbf{x}_i)^T \phi(\mathbf{x}_j) \]</p>
                        <p class="text-sm text-gray-600 mt-2">Computes dot product in high-dimensional feature space without explicitly mapping</p>
                    </div>
                    <div class="formula-highlight p-4 rounded-lg">
                        <h4 class="font-bold text-gray-800 mb-2">Common Kernels</h4>
                        <ul class="text-sm text-gray-700 space-y-1">
                            <li>Linear: \( K(\mathbf{x}_i, \mathbf{x}_j) = \mathbf{x}_i^T \mathbf{x}_j \)</li>
                            <li>Polynomial: \( K(\mathbf{x}_i, \mathbf{x}_j) = (\gamma \mathbf{x}_i^T \mathbf{x}_j + r)^d \)</li>
                            <li>RBF: \( K(\mathbf{x}_i, \mathbf{x}_j) = \exp(-\gamma \|\mathbf{x}_i - \mathbf{x}_j\|^2) \)</li>
                            <li>Sigmoid: \( K(\mathbf{x}_i, \mathbf{x}_j) = \tanh(\gamma \mathbf{x}_i^T \mathbf{x}_j + r) \)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Dual Formulation -->
            <div class="mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-3">4. Dual Formulation</h3>
                <div class="formula-highlight p-4 rounded-lg mb-4">
                    <p class="text-lg font-mono">\[ \text{Maximize: } \sum_{i=1}^{n} \alpha_i - \frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{n} \alpha_i \alpha_j y_i y_j K(\mathbf{x}_i, \mathbf{x}_j) \]</p>
                    <p class="text-lg font-mono mt-2">\[ \text{Subject to: } \sum_{i=1}^{n} \alpha_i y_i = 0, \quad 0 \leq \alpha_i \leq C \]</p>
                    <p class="text-gray-600 text-sm mt-2">Lagrange multipliers \( \alpha_i \) are non-zero only for support vectors</p>
                </div>
            </div>
        </div>

        <!-- Implementation -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Implementation</h2>
            
            <!-- Python Code -->
            <div class="code-card text-white p-6 rounded-lg mb-6">
                <pre class="font-code text-sm overflow-x-auto"><code>import numpy as np
from sklearn import svm
from sklearn.datasets import make_blobs
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
import matplotlib.pyplot as plt

# Generate sample data
X, y = make_blobs(n_samples=100, centers=2, random_state=6)
y = np.where(y == 0, -1, 1)  # SVM uses -1 and 1 for classes

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Create and train SVM model
# Linear kernel
model_linear = svm.SVC(kernel='linear', C=1.0)
model_linear.fit(X_train, y_train)

# RBF kernel
model_rbf = svm.SVC(kernel='rbf', C=1.0, gamma='scale')
model_rbf.fit(X_train, y_train)

# Make predictions
y_pred_linear = model_linear.predict(X_test)
y_pred_rbf = model_rbf.predict(X_test)

# Evaluate
print("Linear SVM:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_linear):.2f}")
print(classification_report(y_test, y_pred_linear))

print("\nRBF SVM:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_rbf):.2f}")
print(classification_report(y_test, y_pred_rbf))

# Get support vectors
print("\nSupport Vectors (Linear):", model_linear.support_vectors_)
print("Number of support vectors:", model_linear.n_support_)

# Plot decision boundary
def plot_decision_boundary(model, X, y):
    h = .02  # step size in the mesh
    x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
    y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
    
    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])
    Z = Z.reshape(xx.shape)
    
    plt.contourf(xx, yy, Z, alpha=0.8)
    plt.scatter(X[:, 0], X[:, 1], c=y, edgecolors='k')
    plt.scatter(model.support_vectors_[:, 0], model.support_vectors_[:, 1], 
                s=100, facecolors='none', edgecolors='red')
    plt.title('SVM Decision Boundary')
    plt.show()

plot_decision_boundary(model_linear, X, y)</code></pre>
            </div>

            <!-- Interactive Demo -->
            <div class="interactive-card text-white p-6 rounded-lg">
                <h3 class="text-xl font-bold mb-4">Interactive SVM Demo</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label class="block mb-2 font-bold">Kernel Type:</label>
                        <select id="kernelType" class="w-full p-2 rounded-lg mb-4 text-gray-800">
                            <option value="linear">Linear</option>
                            <option value="rbf">RBF (Gaussian)</option>
                            <option value="poly">Polynomial</option>
                        </select>
                        
                        <label class="block mb-2 font-bold">Regularization (C):</label>
                        <input type="number" id="regularizationC" value="1.0" min="0.1" max="10" step="0.1" class="w-full p-2 rounded-lg mb-4 text-gray-800">
                        
                        <label class="block mb-2 font-bold">Gamma (for RBF):</label>
                        <input type="number" id="gammaValue" value="0.1" min="0.01" max="10" step="0.01" class="w-full p-2 rounded-lg mb-4 text-gray-800">
                        
                        <button onclick="runSVM()" class="bg-white text-green-600 px-4 py-2 rounded-lg hover:bg-gray-100 transition-colors duration-200 font-bold">
                            Run SVM
                        </button>
                    </div>
                    <div>
                        <canvas id="svmDemoChart" width="400" height="300" style="background-color: white;"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mathematical Theory Card -->
        <div class="math-card text-white p-6 rounded-lg mb-8">
            <h3 class="text-xl font-bold mb-4">Mathematical Theory</h3>
            <div class="space-y-4">
                <div>
                    <h4 class="font-bold mb-2">Statistical Learning Theory</h4>
                    <p class="text-sm">SVM is based on Vapnik-Chervonenkis (VC) theory, which provides bounds on the generalization error. The VC dimension of a hyperplane in d-dimensional space is d+1.</p>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Mercer's Theorem</h4>
                    <p class="text-sm">A continuous symmetric function K(x, y) is a kernel function if and only if for any finite set of points, the Gram matrix is positive semi-definite.</p>
                    <p class="text-sm mt-1">\[ \sum_{i,j} c_i c_j K(x_i, x_j) \geq 0 \quad \forall c_i, c_j \in \mathbb{R} \]</p>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Duality and KKT Conditions</h4>
                    <p class="text-sm">The solution to the SVM optimization problem satisfies the Karush-Kuhn-Tucker (KKT) conditions:</p>
                    <ul class="list-disc list-inside text-xs mt-1">
                        <li>Primal feasibility: \( y_i(\mathbf{w}^T \mathbf{x}_i + b) \geq 1 - \xi_i \)</li>
                        <li>Dual feasibility: \( 0 \leq \alpha_i \leq C \)</li>
                        <li>Complementary slackness: \( \alpha_i (y_i(\mathbf{w}^T \mathbf{x}_i + b) - 1 + \xi_i) = 0 \)</li>
                        <li>Slackness: \( \xi_i (C - \alpha_i) = 0 \)</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-bold mb-2">Computational Complexity</h4>
                    <p class="text-sm">Training time complexity is \( O(n^3) \) in the worst case, but with efficient implementations like SMO (Sequential Minimal Optimization), it can be \( O(n^2) \) or better for large datasets.</p>
                </div>
            </div>
        </div>

        <!-- Evaluation Metrics -->
        <div class="mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Evaluation Metrics</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-check-circle text-2xl text-green-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Accuracy</h3>
                    <p class="text-sm text-gray-600">Overall correctness</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-balance-scale text-2xl text-blue-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Precision</h3>
                    <p class="text-sm text-gray-600">Accuracy of positive predictions</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-eye text-2xl text-purple-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">Recall</h3>
                    <p class="text-sm text-gray-600">Ability to find all positives</p>
                </div>
                <div class="bg-white p-4 rounded-lg shadow-md text-center">
                    <i class="fa fa-star text-2xl text-yellow-500 mb-2"></i>
                    <h3 class="font-bold text-gray-800 mb-1">F1-Score</h3>
                    <p class="text-sm text-gray-600">Harmonic mean of precision and recall</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global chart variables
        let svmMarginChartInstance = null;
        let svmDemoChartInstance = null;
        
        // SVM margin visualization
        function plotSVMMargin() {
            const ctx = document.getElementById('svmMarginChart').getContext('2d');
            
            // Destroy previous chart instance if it exists
            if (svmMarginChartInstance) {
                svmMarginChartInstance.destroy();
            }
            
            // Generate sample data
            const data = {
                class1: [[1, 2], [2, 3], [3, 3], [3, 1], [4, 2]],
                class2: [[5, 6], [6, 5], [6, 7], [7, 6], [8, 7]]
            };
            
            // Calculate decision boundary (simplified)
            const w = [1, -1]; // Weight vector
            const b = -1;      // Bias
            
            // Plot data points
            const datasets = [
                {
                    label: 'Class -1',
                    data: data.class1.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: 'rgba(255, 99, 132, 0.6)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    pointRadius: 6
                },
                {
                    label: 'Class +1',
                    data: data.class2.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: 'rgba(54, 162, 235, 0.6)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    pointRadius: 6
                }
            ];
            
            svmMarginChartInstance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Feature 1' }, min: 0, max: 10 },
                        y: { title: { display: true, text: 'Feature 2' }, min: 0, max: 10 }
                    },
                    plugins: {
                        title: { display: true, text: 'SVM Decision Boundary and Margin' }
                    },
                    animation: {
                        onComplete: function() {
                            // Draw decision boundary and margins
                            const chart = this;
                            const ctx = chart.ctx;
                            ctx.save();
                            
                            // Decision boundary: w·x + b = 0
                            const x1 = 0;
                            const y1 = (-b - w[0] * x1) / w[1];
                            const x2 = 10;
                            const y2 = (-b - w[0] * x2) / w[1];
                            
                            // Margins: w·x + b = ±1
                            const y1_margin1 = (-b - 1 - w[0] * x1) / w[1];
                            const y2_margin1 = (-b - 1 - w[0] * x2) / w[1];
                            const y1_margin2 = (-b + 1 - w[0] * x1) / w[1];
                            const y2_margin2 = (-b + 1 - w[0] * x2) / w[1];
                            
                            // Convert to pixel coordinates
                            const chartArea = chart.chartArea;
                            const xScale = chart.scales.x;
                            const yScale = chart.scales.y;
                            
                            function toPixel(x, y) {
                                return {
                                    x: xScale.getPixelForValue(x),
                                    y: yScale.getPixelForValue(y)
                                };
                            }
                            
                            // Draw margins (dashed lines)
                            ctx.strokeStyle = 'rgba(255, 206, 86, 0.5)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([5, 5]);
                            
                            const p1m1 = toPixel(x1, y1_margin1);
                            const p2m1 = toPixel(x2, y2_margin1);
                            ctx.beginPath();
                            ctx.moveTo(p1m1.x, p1m1.y);
                            ctx.lineTo(p2m1.x, p2m1.y);
                            ctx.stroke();
                            
                            const p1m2 = toPixel(x1, y1_margin2);
                            const p2m2 = toPixel(x2, y2_margin2);
                            ctx.beginPath();
                            ctx.moveTo(p1m2.x, p1m2.y);
                            ctx.lineTo(p2m2.x, p2m2.y);
                            ctx.stroke();
                            
                            // Draw decision boundary (solid line)
                            ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
                            ctx.lineWidth = 3;
                            ctx.setLineDash([]);
                            
                            const p1 = toPixel(x1, y1);
                            const p2 = toPixel(x2, y2);
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }
                }
            });
        }

        // Interactive SVM demo
        function runSVM() {
            const kernel = document.getElementById('kernelType').value;
            const C = parseFloat(document.getElementById('regularizationC').value);
            const gamma = parseFloat(document.getElementById('gammaValue').value);
            
            // Generate non-linear data
            const data = generateNonLinearData();
            
            // Simple SVM visualization
            plotSVMResults(data, kernel, C, gamma);
        }

        function generateNonLinearData() {
            // Generate two interleaving half circles
            const n = 50;
            const class1 = [];
            const class2 = [];
            
            for (let i = 0; i < n; i++) {
                const angle = Math.random() * Math.PI;
                const r = 5 + Math.random() * 2;
                class1.push([
                    r * Math.cos(angle),
                    r * Math.sin(angle)
                ]);
                
                const r2 = 10 + Math.random() * 2;
                class2.push([
                    r2 * Math.cos(angle + Math.PI),
                    r2 * Math.sin(angle + Math.PI)
                ]);
            }
            
            return { class1, class2 };
        }

        function plotSVMResults(data, kernel, C, gamma) {
            const ctx = document.getElementById('svmDemoChart').getContext('2d');
            
            // Destroy previous chart instance if it exists
            if (svmDemoChartInstance) {
                svmDemoChartInstance.destroy();
            }
            
            // Prepare data for Chart.js
            const datasets = [
                {
                    label: 'Class -1',
                    data: data.class1.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: 'rgba(255, 99, 132, 0.6)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    pointRadius: 6
                },
                {
                    label: 'Class +1',
                    data: data.class2.map(p => ({ x: p[0], y: p[1] })),
                    backgroundColor: 'rgba(54, 162, 235, 0.6)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    pointRadius: 6
                }
            ];
            
            svmDemoChartInstance = new Chart(ctx, {
                type: 'scatter',
                data: { datasets },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Feature 1' }, min: -15, max: 15 },
                        y: { title: { display: true, text: 'Feature 2' }, min: -15, max: 15 }
                    },
                    plugins: {
                        title: { 
                            display: true, 
                            text: `SVM with ${kernel.toUpperCase()} Kernel (C=${C}, γ=${gamma})`
                        }
                    },
                    animation: {
                        onComplete: function() {
                            // Draw decision boundary
                            const chart = this;
                            const ctx = chart.ctx;
                            ctx.save();
                            
                            const chartArea = chart.chartArea;
                            const xScale = chart.scales.x;
                            const yScale = chart.scales.y;
                            
                            // Function to convert data coordinates to pixel coordinates
                            function toPixel(x, y) {
                                return {
                                    x: xScale.getPixelForValue(x),
                                    y: yScale.getPixelForValue(y)
                                };
                            }
                            
                            // Function to convert pixel coordinates to data coordinates
                            function toData(pixelX, pixelY) {
                                return {
                                    x: xScale.getValueForPixel(pixelX),
                                    y: yScale.getValueForPixel(pixelY)
                                };
                            }
                            
                            // Generate grid for decision boundary
                            const gridStep = 50;
                            const gridPoints = [];
                            
                            for (let i = 0; i <= gridStep; i++) {
                                for (let j = 0; j <= gridStep; j++) {
                                    const pixelX = chartArea.left + (chartArea.width * i / gridStep);
                                    const pixelY = chartArea.top + (chartArea.height * j / gridStep);
                                    const dataPoint = toData(pixelX, pixelY);
                                    gridPoints.push(dataPoint);
                                }
                            }
                            
                            // Simple kernel functions
                            function linearKernel(x1, x2) {
                                return x1.x * x2.x + x1.y * x2.y;
                            }
                            
                            function rbfKernel(x1, x2, gamma) {
                                const dx = x1.x - x2.x;
                                const dy = x1.y - x2.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                return Math.exp(-gamma * distance * distance);
                            }
                            
                            function polyKernel(x1, x2, gamma, degree = 3) {
                                return Math.pow(gamma * (x1.x * x2.x + x1.y * x2.y) + 1, degree);
                            }
                            
                            // Calculate decision boundary (simplified)
                            function calculateDecision(x, y) {
                                let sum = 0;
                                const testPoint = { x, y };
                                
                                // Sum over all points
                                data.class1.forEach((point, index) => {
                                    const kernelVal = kernel === 'linear' ? linearKernel(testPoint, { x: point[0], y: point[1] })
                                                  : kernel === 'rbf' ? rbfKernel(testPoint, { x: point[0], y: point[1] }, gamma)
                                                  : polyKernel(testPoint, { x: point[0], y: point[1] }, gamma);
                                    sum += -1 * kernelVal; // Class -1
                                });
                                
                                data.class2.forEach((point, index) => {
                                    const kernelVal = kernel === 'linear' ? linearKernel(testPoint, { x: point[0], y: point[1] })
                                                  : kernel === 'rbf' ? rbfKernel(testPoint, { x: point[0], y: point[1] }, gamma)
                                                  : polyKernel(testPoint, { x: point[0], y: point[1] }, gamma);
                                    sum += 1 * kernelVal; // Class +1
                                });
                                
                                return sum;
                            }
                            
                            // Draw decision boundary using contour lines
                            const threshold = 0;
                            const contourPoints = [];
                            
                            // Find points where decision crosses threshold
                            for (let i = 0; i < gridStep; i++) {
                                for (let j = 0; j < gridStep; j++) {
                                    const idx1 = i * (gridStep + 1) + j;
                                    const idx2 = i * (gridStep + 1) + (j + 1);
                                    const idx3 = (i + 1) * (gridStep + 1) + j;
                                    const idx4 = (i + 1) * (gridStep + 1) + (j + 1);
                                    
                                    const p1 = gridPoints[idx1];
                                    const p2 = gridPoints[idx2];
                                    const p3 = gridPoints[idx3];
                                    const p4 = gridPoints[idx4];
                                    
                                    const v1 = calculateDecision(p1.x, p1.y);
                                    const v2 = calculateDecision(p2.x, p2.y);
                                    const v3 = calculateDecision(p3.x, p3.y);
                                    const v4 = calculateDecision(p4.x, p4.y);
                                    
                                    // Check for crossings
                                    if ((v1 <= threshold && v2 >= threshold) || (v1 >= threshold && v2 <= threshold)) {
                                        const t = (threshold - v1) / (v2 - v1);
                                        const x = p1.x + t * (p2.x - p1.x);
                                        const y = p1.y + t * (p2.y - p1.y);
                                        contourPoints.push(toPixel(x, y));
                                    }
                                    
                                    if ((v1 <= threshold && v3 >= threshold) || (v1 >= threshold && v3 <= threshold)) {
                                        const t = (threshold - v1) / (v3 - v1);
                                        const x = p1.x + t * (p3.x - p1.x);
                                        const y = p1.y + t * (p3.y - p1.y);
                                        contourPoints.push(toPixel(x, y));
                                    }
                                }
                            }
                            
                            // Draw decision boundary
                            if (contourPoints.length > 0) {
                                ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
                                ctx.lineWidth = 3;
                                ctx.setLineDash([]);
                                
                                ctx.beginPath();
                                ctx.moveTo(contourPoints[0].x, contourPoints[0].y);
                                
                                for (let i = 1; i < contourPoints.length; i++) {
                                    ctx.lineTo(contourPoints[i].x, contourPoints[i].y);
                                }
                                
                                ctx.stroke();
                            }
                            
                            ctx.restore();
                        }
                    }
                }
            });
        }

        // Initialize charts when page loads
        document.addEventListener('DOMContentLoaded', function() {
            plotSVMMargin();
            runSVM(); // Run initial demo
        });
    </script>
</body>
</html>